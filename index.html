<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Vue Bind</title>
    <script>
      // 1. 整体架构（订阅发布者模式）：Vue类（MVVM类），Watcher类
      // 2. 实现由M到V，把模型的数据绑定到视图
      // 3. 实现由V到M，当文本框输入文本的时候，由文本事件触发更新模型中的数据，
      //    同时更新相对应的视图

      // 发布者
      class Vue {
        constructor(options) {
          // 获取数据
          this.$data = options.data
          // 获取元素对象 #app
          this.$el = document.querySelector(options.el)
          // 容器：保存订阅者信息
          // {greeting: [订阅者1, 订阅者2, ...], myName: [订阅者1, 订阅者2, ...]}
          this.$subs = {}
          this.Observer(this.$data)
          this.Compile(this.$el)
        }
        // 劫持数据：监听数据，通知数据变化
        Observer(data) {
          for (let key in data) {
            // 准备订阅者容器
            this.$subs[key] = []

            let val = data[key]
            let watchers = this.$subs[key]
            Object.defineProperty(this.$data, key, {
              get: function() {
                return val
              },
              set: function(newVal) {
                // 监听数据的改变
                if (newVal !== val) {
                  val = newVal
                  // 触发订阅者视图更新
                  watchers.forEach(watcher => {
                    watcher.update()
                  })
                }
              },
            })
          }
        }
        // 解析指令：收集依赖，订阅
        Compile(el) {
          let nodes = el.children // 获取#app对象下的子对象
          for (let i = 0; i < nodes.length; i++) {
            let node = nodes[i]
            // 递归查找
            if (node.children.length) {
              this.Compile(node)
            }
            if (node.hasAttribute('v-text')) {
              let dataKey = node.getAttribute('v-text')
              // 订阅
              this.$subs[dataKey].push(
                new Watcher(node, this, dataKey, 'innerHTML'),
              )
            }
            if (node.hasAttribute('v-model')) {
              let dataKey = node.getAttribute('v-model')
              this.$subs[dataKey].push(
                new Watcher(node, this, dataKey, 'value'),
              )
              // 绑定更新函数
              node.addEventListener(
                'input',
                function() {
                  this.$data[dataKey] = node.value
                }.bind(this),
              )
            }
          }
        }
      }
      // 订阅者
      class Watcher {
        constructor(el, vm, key, attr) {
          this.el = el
          this.vm = vm
          this.key = key
          this.attr = attr
          // 初始化视图
          this.update()
        }
        update() {
          this.el[this.attr] = this.vm.$data[this.key]
        }
      }
    </script>
  </head>
  <body>
    <div id="app">
      <h1>VUE数据响应式</h1>
      <div>
        <div v-text="greeting"></div>
        <div v-text="myName"></div>
        <input type="text" v-model="greeting" />
        <input type="text" v-model="myName" />
      </div>
    </div>
    <script>
      const app = new Vue({
        el: '#app',
        data: {
          greeting: '大家好！',
          myName: '我是一个例子',
        },
      })
    </script>
  </body>
</html>
